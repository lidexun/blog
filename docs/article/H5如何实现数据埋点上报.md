# H5如何实现数据埋点上报
- 背景
  - 获取用户的喜好与交互体验，优化流程，提升用户体验，提高转化率
  - 具体的按钮/图片点击或曝光上报埋点
- 技术需求
  - 需要适配新/旧项目
  - 不能影响现有业务
## 埋点上报方式?
- 手动埋点
- 可视化埋点
- 自动埋点

### 实现方法
#### 新/旧项目是基于Vue开发,所以需要准备如下
1. 使用Vue自定义事件
2. 发布私有npm包
#### 创建自定义指令文件，在`main.js`注册事件。
```js
// import { version } from 'vue'
class TrackReport {
  constructor(options) {
    this.url = options.url
    this.queen = []
    this.timer = null
    this.maxLogs = options.maxLogs || 20
    this.project = options.project || 'logger'
    this.interval = options.interval || 3000
    this.defaultParams = options.defaultParams
    // 当文档或一个子资源正在被卸载时，触发unload事件。
    window.addEventListener('unload', ()=> {
      this.trySync(true)
    }, false);
  }
  send(data, imd = false) {
    const temp = Object.assign(data, {
      ...this.defaultParams,
      event_time: Math.round(new Date().valueOf() / 1000)
    })
    this.queen.push(temp)
    this.trySync(imd)
  }
  trySync(imd = false) {
    if (this.timer) clearTimeout(this.timer)
    if ((imd || this.queen.length >= this.maxLogs) && this.queen.length) {
      const logs = this.queen.slice(0, this.maxLogs)
      const res = this.syncLog(logs)
      if (res) {
        this.queen = this.queen.slice(this.maxLogs)
      }
    }
    if (this.queen.length) {
      this.timer = setTimeout(() => {
        this.trySync(true)
      }, this.interval)
    }
  }
  syncLog(logs) {
    let res = true
    // 同步日志去服务器
    if (navigator.sendBeacon) {
      const data = JSON.stringify({
        events: logs
      })
      res = navigator.sendBeacon(this.url, data)
    } else {
      let str = Object.entries(logs)
        .map(([key, value]) => `${key}=${value}`)
        .join('&')
      var img = new Image()
      // baseURL = 'https://*****.com/hm.gif?XXXXX';
      img.src = `${baseURL}?${str}`
    }
    return res
  }
}
export default (app, options) => {
  const logger = new TrackReport(options)
  app.directive('track', {
    mounted: (el, binding) => {
      if (JSON.stringify(binding.modifiers) === '{}') {
        return
      }
      let params = {
        ...binding.value
      }
      if (binding.modifiers.view) {
        // 如果是浏览类型，直接保存
        let io = new IntersectionObserver(
          (entries) => {
            for (const entrie of entries) {
              if (entrie.intersectionRatio >= 0.5) {
                io.disconnect()
                logger.send({
                  event_type: 'view',
                  ...params
                })
              }
            }
          },
          {
            root: null,
            rootMargin: '0px',
            threshold: [0, 0.5, 1]
          }
        )
        io.observe(el)
      } else if (binding.modifiers.click) {
        // click类型，监听click事件
        el.addEventListener(
          'click',
          () => {
            logger.send({
              event_type: 'click',
              ...params
            }, true)
          },
          false
        )
      }
    }
  })
}
```